call_me

Firstly I imported the binary into ghidra and then I started observing it.
From entry point I followed the first function called, that is main. In main I have a call of the function FUN_00011308. I went into this func.
I started to analyze it line by line and I came to this part of de compiled code:

    iVar2 = strcmp(acStack_a9 + 1,(&PTR_s_Color_me_your_color,_baby_00014020)[local_14]);
    if (iVar2 == 0) {
      local_10 = local_10 + 1;
      if (local_10 == 3) {
        printf("&target=%p\n",FUN_000111fd);
      }
    }

So, I asked myself how I can achieve that the value of iVar2 is always zero in order that it enters IF statement and to print me target address.
strcmp function returns zero when two compared strings are equal.
So I have to provide 3 strings so that every time the user's input(string) is the same as the value(string) on the address (&PTR_s_Color_me_your_color,_baby_00014020)[local_14].
Then in ghidra I went to the address &PTR_s_Color_me_your_color,_baby_00014020 and I saw the value of it, that is: "Color me your color, baby.
So, I inserted it in the execution of the program, then second string from ghidra and then the third one, and then I obtained a target address.
* By doing this the variable local_10 went to 3 and the program entered second IF statement and printed me the target address.

Computation of the offset:
By sawing the code I got that this program suffers from buffer overflow vulnerability.
I generated the offset in this was: I made a cyclic of 200.
Then, I ran my program with gdb and I inserted generated De Bruijn sequence.
I overwrote return address and I observed eip register $eip   : 0x62616172 ("raab"?).
Then I left the gdb and I computed my offset by doing cyclic -l raab and it's 168.

Function FUN_000111fd:
This is the function that prints flag.
By observing the code I realized that after I insert the offset and the address in payload, I also have to insert 3 parameters to function.
Firstly I tried by strings given in the decompiled code, but I failed. Then I copied the corresponding strings from the listing in ghidra: 0xca55e77e, 0xc0de, 0xdecade; respectively.

Buffer overflow:
I have to change the saved return address of FUN_00011308 with the address of win functions. So when this function returns, it returns the address of win function, it doesn't go back to main.
By inserting the proper offset of 168 I am on top of the stack and then I had to insert 3 parameteres, but before inserting 3 parameters, I had also to fulfiil a slot
reserved for 'ret' in my payload in order to obtain a flag.

Explanation of exit:
If the function FUN_000111fd has 'ret' instruction like the previous function, it would send saved return address and go back to main. Because this is a flow of functions.
The exit instruction, directly exits from the program, it is not returning. It exits without doing anything!
I have to put a value to fulfill a slot of ret instruction, like that my function has a ret instruction.

So I wrote firstly the exit and then 3 parameters in my payload.
* I could put anything inside the payload of the exit. For example p32(0x0).

BASC{you_g0t_the_args_right}.
